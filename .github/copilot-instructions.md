# CRYPTIQ Landing Page – AI Guide

- React 18 + Vite app; entrypoint `src/main.jsx` mounts `App` (StrictMode disabled for performance) and eagerly imports `src/utils/analytics.js`.
- `src/App.jsx` stitches layout sections (Hero → Build → Test → Trade → Demo → FAQ → CTA) and exposes `ContactModal`, `SectionProgress`, plus a dev-only `AnalyticsDashboard` guarded by `import.meta.env.DEV`.
- Component folders mirror section names; each section ships a `.jsx` + `.scss` pair (global styles, not CSS modules). Keep new SCSS colocated and import it inside the component.
- Global styles live under `src/styles/`; scrollbar behavior comes from `initScrollbarAutoHide` which toggles `--scrollbar-opacity`/`--scrollbar-track-color` CSS vars.
- Core workflows: `npm run dev` (Vite dev server), `npm run build`, `npm run preview`, `npm run lint`. `npm test` targets the missing `scripts/run_sim_test.mjs`; use `node scripts/smoke_test.mjs` instead to exercise parser/simulator until that script is restored.
- CoinGecko API utilities: `scripts/ping_coingecko.mjs` verifies credentials; on the client `BacktestView` fetches data with header `x-cg-demo-api-key` (see `COINGECKO_HEADERS`).
- Supabase integration is optional; set `VITE_SUPABASE_URL` and `VITE_SUPABASE_ANON_KEY` to enable writes. Without them analytics fall back to `localStorage` and console notices.
- Two analytics channels exist: site-wide (`src/utils/analytics.js`, consumed via `hooks/useAnalytics.js`) and demo-specific (`src/utils/demoAnalytics.js`). Both queue events until Supabase is ready and expose helper methods on `window.__analytics` / `window.__demoAnalytics`.
- `AnalyticsDashboard.jsx` reads the analytics singleton for debugging; never mount it in production—`App.jsx` already guards it.
- Demo architecture (`src/components/sections/demo`) uses React Flow (`@xyflow/react`). `Demo.jsx` pairs `useNodesState`/`useEdgesState` with rich callbacks for auto-parameter syncing, tutorial overlays, and analytics hooks.
- Initial graph definition in `demo/initial.jsx` seeds nodes, edges, and parameter metadata. New node types must be registered here, in `Demo.jsx` `nodeTypes`, and usually in the parser/simulator pipeline.
- Parameter lifecycles: `initialParameters` describe user and system variables; `reconcileParametersWithAuto` regenerates system parameters when graph structure changes. Preserve flags like `isAutoGenerated` and `source: "system"` so auto-wiring and analytics stay consistent.
- `BacktestView.jsx` orchestrates the simulation: caches CoinGecko price series, spins up `src/workers/backtest.worker.js`, animates charts with Recharts, and reports status back to `Demo`.
- Worker code (`workers/backtest.worker.js`) must remain DOM-free. It deep clones nodes, normalizes if-node variables, resolves parameter bindings, calls `parseGraph` and `runSimulation`, then posts `{ status, data }` messages.
- Graph parsing (`src/utils/parser.js`) extracts `dataProducers`, an entry subgraph feeding the first `buyNode`, and an "in trade" subgraph bounded by the `blockNode` labeled "In a trade". Adjust it if you introduce new control nodes or change block semantics.
- `src/utils/simulator.js` executes the blueprint against price data, honoring `resolveAmountFromNode`, calculating trade stats, and deriving data series via `calculateIndicator`. Any new producer or node output should feed into `buildDataSeries`.
- Indicator math lives in `src/utils/indicators.js`; it maps CoinGecko payloads, synthesizes fallback series, and implements SMA/EMA/RSI/Bollinger/ATR helpers reused by the simulator and charts.
- Demo charts treat worker output as source of truth: indicator series are pulled from `results.dataSeries`, and trade markers rely on `trades[]` indexes. Maintain these keys when extending worker results.
- Supabase-aware analytics requests use `fetch(..., { keepalive: true })` for late events; keep payloads JSON-serializable and lean to stay within Supabase REST limits.
- SEO scripts in `components/SEO/StructuredData.jsx` inject JSON-LD at runtime. When adding new sections or routes, update the structured data arrays accordingly.
- Static assets live under `src/assets/`; fonts are declared in `src/styles/index.css`. Reference them with `import` so Vite handles bundling.
- Contact flows rely on `components/layout/ContactModal.jsx` with shared styling in `layout/contactModal.scss`; keep modal toggles driven via `App` state and lift events up rather than accessing DOM.
- The `SectionProgress` widget highlights the currently viewed section; it depends on consistent `id` attributes (`#build`, `#test`, etc.) on section wrappers.
- Follow existing naming for analytics events (`demoAnalytics.trackX`) so Supabase schemas align; new events should include `properties` with explicit field names (see worker insert logic).
- All SCSS files assume ASCII; stick to the existing color palette and typography tokens defined in shared styles.
- Before large refactors, run `node scripts/smoke_test.mjs` to ensure `parseGraph` + `runSimulation` still return trades and warnings as expected.
