import { StepEdge } from "@xyflow/react";
import {
  DEFAULT_DATA_RESOLUTION,
  DEFAULT_INTERVAL_BY_RESOLUTION,
  DEFAULT_PORTFOLIO_VALUE,
} from "./defaults";

// 1. Define initial parameters for the demo strategy.
const initialParameters = [
  {
    id: "param-1",
    label: "lookback",
    value: "30",
    family: "variable",
    source: "user",
    group: "Core Variables",
  },
  {
    id: "param-2",
    label: "stop_loss_level",
    value: "entry * 0.95",
    family: "variable",
    source: "user",
    group: "Core Variables",
  },
  {
    id: "param-3",
    label: "live_price",
    value: "live_price",
    family: "variable",
    source: "system",
    isDataParameter: true,
    isAutoGenerated: true,
    group: "System",
  },
  {
    id: "param-4",
    label: "indicator_output",
    value: "indicator_output",
    family: "variable",
    source: "system",
    isDataParameter: true,
    isAutoGenerated: true,
    group: "System",
  },
  {
    id: "param-5",
    label: "profit_target",
    value: "entry * 1.10",
    family: "variable",
    source: "user",
    group: "Core Variables",
  },
  {
    id: "param-6",
    label: "entry_price",
    value: "entry",
    family: "variable",
    source: "system",
    isDataParameter: true,
    isAutoGenerated: true,
    group: "System",
  },
];

// Helper to find a parameter by its label for easier wiring.
const getParam = (label) => initialParameters.find((p) => p.label === label);

const bindParam = (label) => {
  const param = getParam(label);
  if (!param) return null;
  return {
    parameterId: param.id,
    label: param.label,
    value: param.value,
    source: param.source || "user",
  };
};

const createVariable = ({
  label,
  id,
  type = "input",
  paramLabel,
  parameterData,
}) => {
  const binding = paramLabel ? bindParam(paramLabel) : null;
  const paramData = parameterData || binding || {};
  const variable = {
    label,
    id,
    type,
    parameterData: paramData,
  };

  if (paramData && paramData.source === "system") {
    variable.paramName = paramData.label;
  }

  return variable;
};

// Helper function to get canvas center based on screen size (same boundaries as zoom)
const getCanvasCenter = () => {
  if (typeof window === "undefined") {
    // Fallback for SSR
    return { x: 720, y: 405 };
  }

  const width = window.innerWidth;
  const height = window.innerHeight;
  const canvasHeight = Math.max(height * 0.75, 650); // 75vh with minHeight 650px

  // Use same media query boundaries as zoom calculation
  let canvasCenterX, canvasCenterY;

  if (width >= 1920) {
    // Extra large desktop (1920px+)
    canvasCenterX = width / 2 - width * 0.14; // ~11.5% of viewport width
    canvasCenterY = canvasHeight / 2 + height * 0.1;
  } else if (width >= 1441) {
    // Large desktop (1441px - 1919px)
    canvasCenterX = width / 2 - width * 0.1;
    canvasCenterY = canvasHeight / 2 + height * 0.1;
  } else if (width >= 1024) {
    // Medium desktop (1024px - 1440px)
    canvasCenterX = width / 2;
    canvasCenterY = canvasHeight / 2 + 200;
  } else {
    // Tablets and below
    canvasCenterX = width / 2;
    canvasCenterY = canvasHeight / 2 - height * 0.5;
  }

  return { x: canvasCenterX, y: canvasCenterY };
};

// Helper function to get initial node positions based on screen size
const getInitialNodePositions = () => {
  const screenWidth = typeof window !== "undefined" ? window.innerWidth : 1440;
  const isSmallScreen = screenWidth < 1441;

  if (isSmallScreen) {
    // Compact layout for screens < 1400px
    return {
      inputIndicatorNode: { x: -200, y: 50 },
      inputPriceNode: { x: -200, y: 300 },
      "setParameterNode-indicator": { x: 400, y: 160 },
      "setParameterNode-price": { x: 200, y: 420 },
      inputNode: { x: -200, y: 550 },
      "ifNode-1": { x: -200, y: 530 },
      "buyNode-1": { x: 60, y: 680 },
      "ifNode-2": { x: 480, y: 350 },
      "sellNode-1": { x: 750, y: 470 },
      "ifNode-3": { x: 480, y: 580 },
      "sellNode-2": { x: 750, y: 700 },
      "recordNode-1": { x: 88, y: 870 },
      "setParameterNode-entry": { x: 410, y: 890 },
      "blockNode-1": { x: 450, y: 300 },
    };
    // -480  +250
  } else {
    // Standard layout for screens >= 1400px
    return {
      inputIndicatorNode: { x: -200, y: 50 },
      inputPriceNode: { x: -200, y: 300 },
      "setParameterNode-indicator": { x: 400, y: 160 },
      "setParameterNode-price": { x: 200, y: 420 },
      inputNode: { x: -200, y: 550 },
      "ifNode-1": { x: 350, y: 280 },
      "buyNode-1": { x: 610, y: 430 },
      "ifNode-2": { x: 960, y: 100 },
      "sellNode-1": { x: 1230, y: 220 },
      "ifNode-3": { x: 960, y: 330 },
      "sellNode-2": { x: 1230, y: 450 },
      "recordNode-1": { x: 638, y: 620 },
      "setParameterNode-entry": { x: 960, y: 640 },
      "blockNode-1": { x: 930, y: 50 },
    };
  }
};

// Helper function to calculate canvas center and center nodes
const centerNodesOnCanvas = (nodes) => {
  // Calculate bounding box of all visible nodes
  const visibleNodes = nodes.filter((node) => !node.hidden);
  if (visibleNodes.length === 0) return nodes;

  const xPositions = visibleNodes.map((node) => node.position.x);
  const yPositions = visibleNodes.map((node) => node.position.y);

  const minX = Math.min(...xPositions);
  const maxX = Math.max(...xPositions);
  const minY = Math.min(...yPositions);
  const maxY = Math.max(...yPositions);

  // Center of the node group
  const nodesCenterX = (minX + maxX) / 2;
  const nodesCenterY = (minY + maxY) / 2;

  // Get canvas center based on screen size
  const { x: canvasCenterX, y: canvasCenterY } = getCanvasCenter();

  // Calculate offset needed to center nodes
  const offsetX = canvasCenterX - nodesCenterX;
  const offsetY = canvasCenterY - nodesCenterY;

  // Apply offset to all nodes
  return nodes.map((node) => ({
    ...node,
    position: {
      x: node.position.x + offsetX,
      y: node.position.y + offsetY,
    },
  }));
};

// 2. Pre-configure nodes with data linked to the initial parameters.
// Organized in logical flow: Input → Indicator → Decision Logic → Execution
// Get initial positions based on screen size
const nodePositions = getInitialNodePositions();

const initialNodesRaw = [
  {
    id: "inputIndicatorNode",
    type: "inputIndicatorNode",
    position: nodePositions["inputIndicatorNode"],
    data: (() => {
      const lookbackBinding = bindParam("lookback");
      const indicatorBinding = bindParam("indicator_output");
      return {
        resolution: "1d",
        lookbackUnit: "d",
        indicator: "sma",
        lookback: Number(lookbackBinding?.value) || 30,
        lookbackParamName: lookbackBinding?.label || "lookback",
        lookbackVariable: {
          label: "lookback",
          id: "lookback-input-indicator",
          parameterData: lookbackBinding || {},
        },
        outputParamName: indicatorBinding?.label || "indicator_output",
        parameters: initialParameters,
        preventInTradeGrouping: true,
      };
    })(),
  },
  {
    id: "inputPriceNode",
    type: "inputPriceNode",
    position: nodePositions["inputPriceNode"],
    data: (() => {
      const livePriceBinding = bindParam("live_price");
      return {
        timeFrame: "1d",
        type: "instant",
        format: "close",
        outputParamName: livePriceBinding?.label || "live_price",
        priceParamData: livePriceBinding || {},
        parameters: initialParameters,
        preventInTradeGrouping: true,
      };
    })(),
  },
  {
    id: "setParameterNode-indicator",
    type: "setParameterNode",
    position: nodePositions["setParameterNode-indicator"],
    data: (() => {
      const indicatorBinding = bindParam("indicator_output");
      return {
        parameterId: indicatorBinding?.parameterId,
        parameterLabel: indicatorBinding?.label || "indicator_output",
        parameterName: indicatorBinding?.label || "indicator_output",
        parameterData: indicatorBinding
          ? { ...indicatorBinding }
          : {
              label: "indicator_output",
              value: "indicator_output",
              source: "system",
            },
        parameters: initialParameters,
        preventInTradeGrouping: true,
      };
    })(),
  },
  {
    id: "setParameterNode-price",
    type: "setParameterNode",
    position: nodePositions["setParameterNode-price"],
    data: (() => {
      const priceBinding = bindParam("live_price");
      return {
        parameterId: priceBinding?.parameterId,
        parameterLabel: priceBinding?.label || "live_price",
        parameterName: priceBinding?.label || "live_price",
        parameterData: priceBinding
          ? { ...priceBinding }
          : {
              label: "live_price",
              value: "live_price",
              source: "system",
            },
        parameters: initialParameters,
        preventInTradeGrouping: true,
      };
    })(),
  },
  {
    id: "inputNode",
    type: "inputNode",
    position: nodePositions["inputNode"],
    hidden: true,
    selectable: false,
    draggable: false,
    style: { opacity: 0, pointerEvents: "none" },
    data: {
      type: "realtime",
      asset: "bitcoin",
      resolution: DEFAULT_DATA_RESOLUTION,
      interval: DEFAULT_INTERVAL_BY_RESOLUTION[DEFAULT_DATA_RESOLUTION],
      portfolioValue: DEFAULT_PORTFOLIO_VALUE,
      parameters: initialParameters,
      preventInTradeGrouping: true,
    },
  },
  {
    id: "ifNode-1",
    type: "ifNode",
    position: nodePositions["ifNode-1"],
    data: {
      label: "If Entry",
      parameters: initialParameters,
      isMaster: true,
      variables: [
        createVariable({
          label: "condition-left",
          id: "ifNode-1-left",
          paramLabel: "live_price",
        }),
        createVariable({
          label: "condition-right",
          id: "ifNode-1-right",
          paramLabel: "indicator_output",
        }),
        createVariable({
          label: "operator",
          id: "ifNode-1-operator",
          type: "operator",
          parameterData: { value: ">" },
        }),
      ],
      operator: ">",
      preventInTradeGrouping: true,
    },
  },
  {
    id: "buyNode-1",
    type: "buyNode",
    position: nodePositions["buyNode-1"],
    data: {
      label: "Buy",
      action: "buy",
      parameters: initialParameters,
      preventInTradeGrouping: true,
    },
  },
  {
    id: "ifNode-2",
    type: "ifNode",
    position: nodePositions["ifNode-2"],
    data: {
      label: "If Exit (Stop-Loss)",
      parameters: initialParameters,
      variables: [
        createVariable({
          label: "condition-left",
          id: "ifNode-2-left",
          paramLabel: "live_price",
        }),
        createVariable({
          label: "condition-right",
          id: "ifNode-2-right",
          paramLabel: "stop_loss_level",
        }),
        createVariable({
          label: "operator",
          id: "ifNode-2-operator",
          type: "operator",
          parameterData: { value: "<" },
        }),
      ],
      operator: "<",
    },
  },
  {
    id: "sellNode-1",
    type: "sellNode",
    position: nodePositions["sellNode-1"],
    data: {
      label: "Sell (Stop-Loss)",
      action: "sell",
      amount: "100",
      parameters: initialParameters,
    },
  },
  {
    id: "ifNode-3",
    type: "ifNode",
    position: nodePositions["ifNode-3"],
    data: {
      label: "If Exit (Profit)",
      parameters: initialParameters,
      variables: [
        createVariable({
          label: "condition-left",
          id: "ifNode-3-left",
          paramLabel: "live_price",
        }),
        createVariable({
          label: "condition-right",
          id: "ifNode-3-right",
          paramLabel: "profit_target",
        }),
        createVariable({
          label: "operator",
          id: "ifNode-3-operator",
          type: "operator",
          parameterData: { value: ">" },
        }),
      ],
      operator: ">",
    },
  },
  {
    id: "sellNode-2",
    type: "sellNode",
    position: nodePositions["sellNode-2"],
    data: {
      label: "Sell (Profit)",
      action: "sell",
      amount: "100",
      parameters: initialParameters,
    },
  },
  {
    id: "recordNode-1",
    type: "recordNode",
    position: nodePositions["recordNode-1"],
    data: {
      recordType: "entry_price",
      recordValue: "",
      parameters: initialParameters,
      preventInTradeGrouping: true,
    },
  },
  {
    id: "setParameterNode-entry",
    type: "setParameterNode",
    position: nodePositions["setParameterNode-entry"],
    data: (() => {
      const entryBinding = bindParam("entry_price");
      return {
        parameterId: entryBinding?.parameterId,
        parameterLabel: entryBinding?.label || "entry_price",
        parameterName: entryBinding?.label || "entry_price",
        parameterData: entryBinding
          ? { ...entryBinding }
          : {
              label: "entry_price",
              value: "entry",
              source: "system",
            },
        parameters: initialParameters,
        preventInTradeGrouping: true,
      };
    })(),
  },
  {
    id: "blockNode-1",
    type: "blockNode",
    position: nodePositions["blockNode-1"],
    data: {
      label: "In a trade",
      parameters: initialParameters,
      anchorNodeId: "buyNode-1",
    },
  },
];

// Center all nodes on the canvas
const initialNodes = centerNodesOnCanvas(initialNodesRaw);

// Edge types for ReactFlow - use step edges instead of smooth
const edgeTypes = {
  default: StepEdge,
  step: StepEdge,
  // Custom step edge with shorter initial segment
  shortStep: (props) => (
    <StepEdge
      {...props}
      pathOptions={{
        offset: 2, // Very small offset for shorter initial segment
        borderRadius: 0,
      }}
    />
  ),
  // Apply shortStep to existing edge types
  dataFlow: (props) => (
    <StepEdge
      {...props}
      pathOptions={{
        offset: 1,
        borderRadius: 0,
      }}
    />
  ),
  execution: (props) => (
    <StepEdge
      {...props}
      pathOptions={{
        offset: 1,
        borderRadius: 0,
      }}
    />
  ),
};

const initialEdges = [
  {
    id: "indicator-to-parameter",
    source: "inputIndicatorNode",
    target: "setParameterNode-indicator",
    type: "dataFlow",
    animated: true,
    style: {
      stroke: "#000000",
      strokeWidth: 3,
      strokeDasharray: "5,5",
    },
  },
  {
    id: "price-to-parameter",
    source: "inputPriceNode",
    target: "setParameterNode-price",
    type: "dataFlow",
    animated: true,
    style: {
      stroke: "#000000",
      strokeWidth: 3,
      strokeDasharray: "5,5",
    },
  },
  {
    id: "record-to-parameter",
    source: "recordNode-1",
    sourceHandle: "recordNode-1-right",
    target: "setParameterNode-entry",
    type: "dataFlow",
    animated: true,
    style: {
      stroke: "#000000",
      strokeWidth: 3,
      strokeDasharray: "5,5",
    },
  },
  // Entry decision - True path
  {
    id: "n3.1-n4.1",
    source: "ifNode-1",
    sourceHandle: "ifNode-1-true",
    target: "buyNode-1",
    targetHandle: "buyNode-1-left",
    type: "execution",
    animated: true,
    style: {
      stroke: "#000000",
      strokeWidth: 3,
      strokeDasharray: "5,5",
    },
  },
  // Stop-loss decision - True path
  {
    id: "n3.2-n4.2",
    source: "ifNode-2",
    sourceHandle: "ifNode-2-true",
    target: "sellNode-1",
    targetHandle: "sellNode-1-left",
    type: "execution",
    animated: true,
    style: {
      stroke: "#000000",
      strokeWidth: 3,
      strokeDasharray: "5,5",
    },
  },
  // Profit decision - True path
  {
    id: "n3.3-n4.3",
    source: "ifNode-3",
    sourceHandle: "ifNode-3-true",
    target: "sellNode-2",
    targetHandle: "sellNode-2-left",
    type: "execution",
    animated: true,
    style: {
      stroke: "#000000",
      strokeWidth: 3,
      strokeDasharray: "5,5",
    },
  },
  // Buy to Record connection
  {
    id: "buy-record",
    source: "buyNode-1",
    sourceHandle: "buyNode-1-bottom",
    target: "recordNode-1",
    targetHandle: "recordNode-1-top",
    type: "dataFlow",
    animated: true,
    style: {
      stroke: "#000000",
      strokeWidth: 3,
      strokeDasharray: "5,5",
    },
  },
];

export { initialNodes, initialEdges, initialParameters, edgeTypes };
