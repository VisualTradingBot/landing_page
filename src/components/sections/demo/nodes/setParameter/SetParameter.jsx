import "./setParameter.scss";
import NodeDefault from "../nodeDefault";
import PropTypes from "prop-types";
import { useState, useEffect, useMemo, useRef } from "react";
import { useReactFlow } from "@xyflow/react";

const DEFAULT_LABEL = "parameter";
const DEFAULT_SOURCE = "system";
const SYSTEM_COLOR_VARIANTS = [
  "system-variant-1",
  "system-variant-2",
  "system-variant-3",
];

const pickSystemVariantByLabel = (label) => {
  if (typeof label !== "string") {
    return null;
  }
  const normalized = label.toLowerCase();
  if (normalized.includes("live")) {
    return "system-variant-1";
  }
  if (normalized.includes("output") || normalized.includes("indicator")) {
    return "system-variant-2";
  }
  if (normalized.includes("entry")) {
    return "system-variant-3";
  }
  if (normalized.includes("close")) {
    return "system-variant-3";
  }
  return null;
};

const getSystemColorVariant = (identifier) => {
  const sourceString = String(identifier || "");
  if (!sourceString) {
    return SYSTEM_COLOR_VARIANTS[0];
  }

  let hash = 0;
  for (let index = 0; index < sourceString.length; index += 1) {
    hash += sourceString.charCodeAt(index);
  }

  return SYSTEM_COLOR_VARIANTS[hash % SYSTEM_COLOR_VARIANTS.length];
};

const resolveLabel = (nodeData) => {
  if (!nodeData) return DEFAULT_LABEL;
  const candidates = [
    nodeData.parameterLabel,
    nodeData.parameterName,
    nodeData.parameterData?.label,
  ];

  for (const candidate of candidates) {
    if (typeof candidate === "string" && candidate.trim()) {
      return candidate.trim();
    }
  }

  return DEFAULT_LABEL;
};

const resolveValue = (nodeData, fallbackLabel) => {
  if (!nodeData) return fallbackLabel;
  const raw = nodeData.parameterData?.value;
  if (typeof raw === "string" && raw.trim()) {
    return raw.trim();
  }
  return fallbackLabel;
};

const resolveSource = (nodeData) => {
  const raw = nodeData?.parameterData?.source;
  if (typeof raw === "string" && raw.trim()) {
    return raw.trim();
  }
  return DEFAULT_SOURCE;
};

export default function SetParameter({ data, id }) {
  const { updateNodeData } = useReactFlow();

  const parameterIdRef = useRef(
    data?.parameterId ||
      data?.parameterData?.parameterId ||
      `set-parameter-${id || Date.now()}`
  );
  const parameterId = parameterIdRef.current;

  const initialLabel = useMemo(() => resolveLabel(data), [data]);
  const [label, setLabel] = useState(initialLabel);
  const [value, setValue] = useState(() => resolveValue(data, initialLabel));

  const source = useMemo(() => resolveSource(data), [data]);

  useEffect(() => {
    const nextLabel = resolveLabel(data);
    if (nextLabel !== label) {
      setLabel(nextLabel);
    }

    const nextValue = resolveValue(data, nextLabel);
    if (nextValue !== value) {
      setValue(nextValue);
    }
  }, [data, label, value]);

  const parameterData = useMemo(
    () => ({
      parameterId,
      label,
      value,
      source,
      isDataParameter: true,
      isAutoGenerated: true,
    }),
    [label, parameterId, source, value]
  );

  useEffect(() => {
    const existing = data || {};
    const needsUpdate =
      existing.parameterId !== parameterId ||
      existing.parameterName !== label ||
      existing.parameterLabel !== label ||
      !existing.parameterData ||
      existing.parameterData.label !== label ||
      existing.parameterData.value !== value ||
      (existing.parameterData.source || DEFAULT_SOURCE) !== source;

    if (!id || !needsUpdate) return;

    const {
      parameterId: _ignoredId,
      parameterName: _ignoredName,
      parameterLabel: _ignoredLabel,
      parameterData: _ignoredData,
      ...rest
    } = existing;

    updateNodeData(id, {
      ...rest,
      parameterId,
      parameterName: label,
      parameterLabel: label,
      parameterData,
    });
  }, [
    data,
    id,
    label,
    parameterData,
    parameterId,
    source,
    updateNodeData,
    value,
  ]);

  useEffect(() => {
    const handleParametersUpdated = (event) => {
      const params = event?.detail || event;
      if (!Array.isArray(params)) return;

      const match = params.find((param) => param.id === parameterId);
      if (!match) return;

      if (typeof match.label === "string") {
        const nextLabel = match.label.trim() || DEFAULT_LABEL;
        if (nextLabel !== label) {
          setLabel(nextLabel);
        }
      }

      if (typeof match.value === "string") {
        const nextValue = match.value.trim() || label;
        if (nextValue !== value) {
          setValue(nextValue);
        }
      }
    };

    window.addEventListener("parametersUpdated", handleParametersUpdated);
    return () => {
      window.removeEventListener("parametersUpdated", handleParametersUpdated);
    };
  }, [label, parameterId, value]);

  const colorVariant = useMemo(
    () => {
      const preset = pickSystemVariantByLabel(label);
      return preset || getSystemColorVariant(parameterId || label);
    },
    [label, parameterId]
  );

  const displayValue = value && value.trim() ? value.trim() : "[Auto-generated]";

  return (
    <NodeDefault
      id={id}
      title="Set Parameter"
      left={{ active: true, type: "target" }}
    >
      <div className="set-parameter-node">
        <div
          className={`set-parameter-card parameter-item ${colorVariant}`}
        >
          <span className="parameter-label">
            <span className={`parameter-icon ${colorVariant}`}>â¬¤</span>
            <span className="parameter-label-content">{label}</span>
          </span>
        </div>
      </div>
    </NodeDefault>
  );
}

SetParameter.propTypes = {
  id: PropTypes.string,
  data: PropTypes.object,
};